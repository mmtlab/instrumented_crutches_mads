/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for LoadcellPlugin, a Filter Plugin
# Generated by the command: C:\Program Files\MADS\usr\local\bin\mads-plugin.exe -t filter -d C:\mirrorworld\instrumented_crutches\loadcell loadcell
# Hostname: unknown
# Current working directory: C:\mirrorworld\instrumented_crutches
# Creation date: 2026-01-11T18:28:16.919+0100
# NOTICE: MADS Version 1.4.0
*/

// To run this plugin remember to use the command with the --dont-block option enabled to avoid blocking while waiting for new data in sub_topic
// mads-filter loadcell.plugin --dont-block 

// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <memory>          // For std::unique_ptr
#include <chrono>          // For timing

// Platform detection
#ifdef __arm__
  #define PLATFORM_RASPBERRY_PI
#elif defined(_WIN32) || defined(_WIN64)
  #define PLATFORM_WINDOWS
#endif

// Include HX711 only on Raspberry Pi
#ifdef PLATFORM_RASPBERRY_PI
  #include <hx711/common.h>  // Library for HX711
  using namespace HX711;
#endif

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "loadcell"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;
using namespace std::chrono;


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class LoadcellPlugin : public Filter<json, json> {

public:

  // Constructor
  LoadcellPlugin() : _hx(nullptr) {}

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    
    // if topic is "command", process commands here
    if (topic == "command") {
      if (!input.contains("command")) {
        return return_type::retry;
      }

      string action = input["command"];
      if (action == "start") {
        if (_acquiring) {
          _error = "Loadcell: start requested while already acquiring";
          std::cout << std::endl << "\033[31m" << "Error: " << _error << "\033[0m" << std::endl;
          return return_type::warning;
        }
        _acquiring = true;
        std::cout << std::endl << "Loadcell: Starting acquisition" << std::endl;
      } else if (action == "stop") {
        if (_acquiring == false) {
          _error = "Loadcell: stop requested while not acquiring";
        std::cout << std::endl << "\033[31m" << "Error: " << _error << "\033[0m" << std::endl;
          return return_type::warning;
        }
        _acquiring = false;
        std::cout << std::endl << "Loadcell: Stopping acquisition" << std::endl;
      } else if (action == "set_offset") {
        if (_acquiring) {
          _error = "Loadcell: set_offset not allowed while acquiring, request ignored";
        std::cout << std::endl << "\033[31m" << "Error: " << _error << "\033[0m" << std::endl;
          return return_type::error;
        }
        _setting_offset = true;
        std::cout << std::endl << "Loadcell: Setting offset" << std::endl;
      } else {
        _error = "Loadcell: unknown command '" + action + "'";
        std::cout << std::endl << "\033[31m" << "Error: " << _error << "\033[0m" << std::endl;
        return return_type::error;
      }
    }

    return return_type::success;
  }

  // We calculate the average of the last N values for each key and store it
  // into the output json object
  return_type process(json &out) override {
    out.clear();

    // Not valid states are handled in load_data, here we just process data
    // Here we should have only valid states and errors related to reading the sensor


    // load the data as necessary and set the fields of the json out variable
    if (_acquiring) {
      auto now = std::chrono::system_clock::now();
      out["ts_" + _params["side"].get<string>()] = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();

#ifdef PLATFORM_RASPBERRY_PI

      try {
        // Real hardware acquisition on Raspberry Pi
        if (_hx && _enabled) {
          double loadCellValue = _hx->weight(1).getValue(Mass::Unit::N);
          out[_params["side"]] = loadCellValue - _offset;
        }
      } catch (const std::exception &e) {
        _error = "Loadcell: Error reading from HX711: " + string(e.what());
        return return_type::warning;
      }
      
#else

      // Windows simulation mode
      out[_params["side"]] = _debug_offset + (rand() % 6 - 3) - _offset; // Simulated data with noise

#endif

    } else if (_setting_offset && _acquiring == false) {
#ifdef PLATFORM_RASPBERRY_PI

      try {
        // Real hardware offset on Raspberry Pi
        _offset = _hx->weight(20).getValue(Mass::Unit::N);
        _setting_offset = false;

        // test read after setting offset
        auto offset_test = _hx->weight(20).getValue(Mass::Unit::N) - _offset;
        
        out["offset_" + _params["side"].get<string>()] = _offset;
        out["offset_test_" + _params["side"].get<string>()] = offset_test;

      } catch (const std::exception &e) {
        _error = "Loadcell: Error reading from HX711 for offset: " + string(e.what());
        return return_type::warning;
      }
#else
      // Windows simulation mode
      _offset = _debug_offset;
      _setting_offset = false;
      
      // test read after setting offset
      auto offset_test = 0.0;

      out["offset_" + _params["side"].get<string>()] = _offset;
      out["offset_test_" + _params["side"].get<string>()] = offset_test;
#endif
      
    } else {
      return return_type::retry;
    }

    // This sets the agent_id field in the output json object, only when it is
    // not empty
    if (!_agent_id.empty()) out["agent_id"] = _agent_id;
    return return_type::success;
  }
  
  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);

    // provide sensible defaults for the parameters by setting e.g.
    _params["side"] = "unknown";

    _debug_offset = (rand() % 100 - 50); // Emulate some offset value

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(*(json *)params);

    if (_params.contains("side") && (_params["side"] == "left" || _params["side"] == "right")) {
      std::cout << "Loadcell: Side set to " << _params["side"] << std::endl;
    } else {
      _error = "Loadcell: Side parameter not set or invalid (only 'left' or 'right' allowed)";
      std::cout << _error << std::endl;
      throw std::runtime_error(_error);
    }

#ifdef PLATFORM_RASPBERRY_PI
    // Read configuration parameters for the single HX711 sensor (Raspberry Pi only)
    if (_params.contains("datapin") && _params.contains("clockpin") && _params.contains("scaling")) {
      int dataPin = _params["datapin"].get<int>();
      int clockPin = _params["clockpin"].get<int>();
      double scaling = _params["scaling"].get<double>();
      _enabled = _params.value("enabled", true);  // Default to true if not specified
      
      // Initialize the HX711 sensor
      if (_enabled && dataPin != -1 && clockPin != -1) {
        _hx = std::make_unique<AdvancedHX711>(dataPin, clockPin, scaling, 0.0, Rate::HZ_80);
        std::cout << "Loadcell: HX711 initialized with dataPin=" << dataPin 
                  << ", clockPin=" << clockPin << ", scaling=" << scaling << std::endl;
      }
    } else {
      std::cerr << "Missing required parameters: datapin, clockpin, or scaling" << std::endl;
      throw std::invalid_argument("Missing required parameters for HX711 configuration");
    }
#else
    // Windows: parameters are optional since we're simulating
    std::cout << "Loadcell: Running in SIMULATION MODE (Windows)" << std::endl;
#endif

    _setting_offset = true; // Set offset at the beginning
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };

private:
  // Define the fields that are used to store internal resources

#ifdef PLATFORM_RASPBERRY_PI
  unique_ptr<AdvancedHX711> _hx;  // Single HX711 sensor (Raspberry Pi only)
#else
  void* _hx = nullptr;  // Placeholder for Windows compilation
#endif

  // Control flags
  bool _enabled = false;
  bool _acquiring = false;
  bool _setting_offset = false;

  // Internal variables
  float _debug_offset = 0.0;
  float _offset = 0.0;
  
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(LoadcellPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

int main(int argc, char const *argv[])
{
  LoadcellPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {
    {"AX", 1},
    {"AY", 2},
    {"AZ", 3}
  };

  // Set input data
  plugin.load_data(input);
  cout << "Input: " << input.dump(2) << endl;

  // Process data
  plugin.process(output);
  cout << "Output: " << output.dump(2) << endl;


  return 0;
}

