/*
  ____  _       _            _             _       
 / ___|(_)_ __ | | __  _ __ | |_   _  __ _(_)_ __  
 \___ \| | '_ \| |/ / | '_ \| | | | |/ _` | | '_ \ 
  ___) | | | | |   <  | |_) | | |_| | (_| | | | | |
 |____/|_|_| |_|_|\_\ | .__/|_|\__,_|\__, |_|_| |_|
                      |_|            |___/         
# A Template for Hdf5_writerPlugin, a Sink Plugin
# Generated by the command: plugin --type sink --dir hdf5_writer --install-dir /Users/p4010/usr/local HDF5_WRITER
# Hostname: Fram-IV-2.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2025-07-09T12:52:15.976+0200
# NOTICE: MADS Version 1.3.1
*/

// Mandatory included headers
#include <sink.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
#include <H5Cpp.h>
#include <sstream>
#include "json2hdf5.hpp"
// other includes as needed here

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "hdf5"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Hdf5Plugin : public Sink<json> {

public:
  ~Hdf5Plugin() {
    // Constructor implementation, if needed
    try {
      _converter.close();
    } catch (const H5::Exception &e) {
      _error = "Error closing HDF5 file: " + string(e.getDetailMsg());
    }
  }

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {

    // if topic is "command", process commands here
    if (topic == "command"){

      if(!input.contains("command")) {
        _error = "Hdf5_writer: missing command in payload";
        return return_type::error;
      }

      string action = input["command"];

      if (action == "start") {
        if (_recording) {
          _error = "Hdf5_writer: start requested while already recording";
          return return_type::warning;
        }
        if (!input.contains("id")) {
          _error = "Hdf5_writer: start command requires an id";
          return return_type::error;
        }

        _converter.close(); // Close any previously opened file

        int id = input["id"];
        // Open a new file for recording
        string new_filename = "_" + to_string(id) + ".h5";

        if (new_filename == _filename) {
          _filename = "not_handled_filename.h5"; // reset filename to avoid overwriting in case of new recording without restart
          _error = "Hdf5_writer: filename collision detected for id: " + to_string(id);
          return return_type::error;
        } else {
          _filename = new_filename;
        }

        try {
          _converter.open(_folder_path + _filename);
        } catch (const std::exception &e) {
          _error = "Error opening HDF5 file: " + string(e.what());
          return return_type::error;
        }
        _recording = true;
        std::cout << "Hdf5_writer: Starting recording id: " << id << std::endl;

        return return_type::success;
        // other actions as needed
      } else if (action == "stop") {
        if (_recording == false) {
          _error = "Hdf5_writer: stop requested while not recording";
          return return_type::warning;
        }

        std::cout << "Hdf5_writer: Stopping recording " << std::endl;

        try{
          _converter.close(); // Close the current file
        } catch (const H5::Exception &e) {
          _error = "Error closing HDF5 file: " + string(e.getDetailMsg());
          std::cerr << _error << std::endl;
          return return_type::error;
        }

        // rename the file to indicate end of acquisition
        string new_filename = _filename.substr(1, _filename.size() - 1); // remove leading underscore
        if (std::rename((_folder_path + _filename).c_str(), (_folder_path + new_filename).c_str()) != 0) {
          _error = "Error renaming file " + _filename + " to " + new_filename;
          return return_type::warning;
        }

        _recording = false;
        std::cout << "Hdf5_writer: Stopping recording"<< std::endl;
        
        return return_type::success;

      }
      else if (action == "set_offset") {
        // No action needed for set_offset in HDF5 sink
        return return_type::retry;
      }
      else {
        _error = "Invalid command or state for command: " + action;
        std::cerr << _error << std::endl;
        return return_type::error;
      }
    }

    if (_recording && topic != "command") {
      if (std::find(_converter.groups().begin(), _converter.groups().end(), topic) == _converter.groups().end()) {
        _error = "Topic '" + topic + "' not found in keypaths.";
        return return_type::warning;
      }
      try {
        _converter.save_to_group(input, topic);
      } catch (const std::exception &e) {
        _error = "Error converting JSON to HDF5: " + string(e.what());
        return return_type::warning;
      }
    }
     
    return return_type::success;
  }

  void set_params(const json &params) override { 
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Sink::set_params(params);

    // provide sensible defaults for the parameters by setting e.g.
    _params["keypath_sep"] = "."; // Default keypath separator
    _params["sensor"] = "unknown";
    _params["folder_path"] = "./data/";
    
    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(params);

    _folder_path = _params.value("folder_path", "./fallback_data/");
    _folder_path += (_folder_path.back() == '/') ? "" : "/"; // Ensure trailing slash


    try {
      _converter.set_keypath_separator(_params["keypath_sep"].get<string>());
      for (const auto &group : _params["keypaths"].items()) {
        for (const auto &keypath : group.value()) {
          _converter.append_keypath(keypath.get<string>(), group.key());
        }
      }
    } catch (const std::exception &e) {
      _error = "Error setting keypaths: " + string(e.what());
      std::cerr << _error << std::endl;
      return;
    }
    
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    map<string, string> info_map;
    info_map["Folder path"] = _folder_path;
    stringstream ss;
    size_t total_keypaths = 0;
    for (const auto &group : _converter.groups()) {
      for (const auto &keypath : _converter.keypaths(group)) {
        ss << group << _converter.keypath_separator() << keypath << ", ";
      }
      total_keypaths += _converter.keypaths(group).size();
    }
    if (!ss.str().empty()) {
      ss.seekp(-2, ss.cur); // Remove the last comma and space
    }
    ss << " (total: " << total_keypaths << ")";
    info_map["Keypaths"] = ss.str();
    info_map["Keypath sep."] = _converter.keypath_separator();
    return info_map;
  };

private:
  // Define the fields that are used to store internal resources
  JsonToHdf5Converter _converter; // Converter for JSON to HDF5

  // settings variables
  string _folder_path = "";
  string _filename = "";

  // control variables
  bool _recording = false;
};



/*
  ____  _             _             _      _                
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __ 
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |   
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|   
                |___/                                      
Enable the class as plugin 
*/
INSTALL_SINK_DRIVER(Hdf5Plugin, json)


/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  Hdf5Plugin plugin;
  json input, params;

  // Initialize the input data
  input = {
    {"timecode", 1234567890},
    {"timestamp", "2025-07-09T12:52:15.976+0200"},
    {"hostname", "Fram-IV.local"},
    {"data", {
      {"key1", "value1"}, 
      {"key2", 42}, 
      {"key3", {1, 2, 3, 4, 5}},
      {"key4", {{"subkey1", "subvalue1"}, {"subkey2", "subvalue2"}}}
    }}
  };

  // Set example values to params
  params["filename"] = "validation_test.h5";
  params["keypaths"]["test_topic"] = {
    "data.key1", "data.key2", "data.key3", "data.key4.subkey1", "data.key4.subkey2"};

  // Set the parameters
  plugin.set_params(params);

  for (const auto &info : plugin.info()) {
    cout << info.first << ": " << info.second << endl;
  }

  // Process data
  if (plugin.load_data(input, "test_topic") != return_type::success) {
    cerr << "Error: " << plugin.error() << endl;
    return 1;
  }

  cout << "Data successfully written to HDF5 file." << endl;
  return 0;

}
