/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Status_handlerPlugin, a Filter Plugin
# Generated by the command: C:\Program Files\MADS\usr\local\bin\mads-plugin.exe -t filter -d C:\mirrorworld\instrumented_crutches\status_handler status_handler
# Hostname: unknown
# Current working directory: C:\mirrorworld\instrumented_crutches\status_handler
# Creation date: 2026-01-29T10:48:01.664+0100
# NOTICE: MADS Version 2.0.0
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <deque>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <cctype>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "status_handler"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Status_handlerPlugin : public Filter<json, json> {

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    _last_input = input;
    _last_topic = topic;

    // Normalize source based on topic or agent_id/name
    string source = topic.empty() ? "unknown" : topic;
    if (input.contains("name")) {
      try {
        source = input["name"].get<string>();
      } catch (...) {
        // keep topic as source
      }
    } else if (input.contains("agent_id")) {
      try {
        source = input["agent_id"].get<string>();
      } catch (...) {
        // keep topic as source
      }
    }

    auto to_lower = [](string s) {
      std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c){ return std::tolower(c); });
      return s;
    };

    auto get_string = [&](const char *key) -> string {
      if (!input.contains(key)) return "";
      try { return input[key].get<string>(); } catch (...) { return ""; }
    };

    string level = "";
    string message = "";
    string side = "";
    bool has_error = false;

    // Handle error format: info.error = ["where", "message"]
    if (input.contains("info") && input["info"].is_object()) {
      try {
        auto info = input["info"];
        
        // Helper to extract message from array field
        auto extract_from_array = [&](const char* field, const char* lvl) {
          if (info.contains(field) && info[field].is_array()) {
            has_error = true;
            level = lvl;
            auto& arr = info[field];
            if (message.empty() && arr.size() >= 2 && arr[1].is_string()) {
              message = arr[1].get<string>();
            }
            if (message.empty() && arr.size() >= 1 && arr[0].is_string()) {
              message = arr[0].get<string>();
            }
            return true;
          }
          return false;
        };
        
        extract_from_array("error", "error") || 
        extract_from_array("warning", "warning") || 
        extract_from_array("fatal", "fatal");
        
      } catch (...) {}
    }

    // Extract side from settings.side if present
    if (input.contains("modified_settings") && input["modified_settings"].is_object()) {
      try {
        auto settings = input["modified_settings"];
        if (settings.contains("side") && settings["side"].is_string()) {
          side = settings["side"].get<string>();
        }
      } catch (...) {}
    } else if (input.contains("settings") && input["settings"].is_object()) {
      try {
        auto settings = input["settings"];
        if (settings.contains("side") && settings["side"].is_string()) {
          side = settings["side"].get<string>();
        }
      } catch (...) {}
    }

    // Handle the shutdown messages
    bool has_shutdown = false;
    if (input.contains("event") && input["event"].is_string() && input["event"].get<string>() == "shutdown") {
      has_shutdown = true;
      level = "critical";
      
      // Build shutdown message
      std::ostringstream oss;
      oss << "shutdown";
      
      message = oss.str();
      
      if (_debug) {
        std::cout << "StatusHandler: the agent " << source << " is shutting down." << std::endl;
      }
    }

    // Handle the startup messages
    bool has_startup = false;
    if (input.contains("event") && input["event"].is_string() && input["event"].get<string>() == "startup") {
      has_startup = true;
      level = "info";
      
      // Build startup message
      std::ostringstream oss;
      oss << "startup";
      
      message = oss.str();
      
      if (_debug) {
        std::cout << "StatusHandler: the agent " << source << " is starting up." << std::endl;
      }
    }

    // Handle offset messages from loadcell topic
    bool has_offset = false;
    if (input.contains("offset") && input.contains("offset_test")) {
      has_offset = true;
      level = "warning";
      side = "unknown";
      
      if (input["offset"].contains("left") && input["offset_test"].contains("left")) {
        side = "left";
      } else if (input["offset"].contains("right") && input["offset_test"].contains("right")) {
        side = "right";
      }

      // Build offset message
      std::ostringstream oss;
      oss << "offset = " << input["offset"][side] << " N, test = " << input["offset_test"][side] << " N";
      
      message = oss.str();
      if (_debug) {
        std::cout << "StatusHandler: offset detected topic='" << topic << "' message='" << message << "'" << std::endl;
      }
    }

    // Handle pupil neon info messages 
    bool has_neon_info = false;
    if (input.contains("pupil_neon_connected") || input.contains("pupil_neon_connection_error")) {
      has_neon_info = true;

      // Build neon info message
      std::ostringstream oss;
      oss  << (input.value("pupil_neon_connected", false) ? "" : "=not connected");

      if (input.contains("pupil_neon_connection_error") && !input["pupil_neon_connection_error"].is_null()) {
        level = "error";
        oss << input["pupil_neon_connection_error"].get<string>();
      } else {
        level = "info";
      }
      
      message = oss.str();
      
      if (_debug) {
        std::cout << "StatusHandler: pupil_neon topic='" << topic << "' message='" << message << "'" << std::endl;
      }
    }

    // If level indicates an issue, build message
    bool is_relevant = has_error || has_offset || has_shutdown || has_startup || has_neon_info || (level == "info" || level == "warning" || level == "error" || level == "fatal" || level == "critical");

    if (is_relevant) {
      if (_debug) {
        std::cout << "StatusHandler: issue detected level='" << level << "' source='" << source << "'";
        if (!side.empty()) std::cout << " side='" << side << "'";
        std::cout << " message='" << message << "'" << std::endl;
      }
      if (message.empty()) {
        message = get_string("message");
      }
      if (message.empty()) {
        message = get_string("detail");
      }
      if (message.empty()) {
        message = "Unhandled error event";
      }

      json out_msg;
      out_msg["source"] = source;
      out_msg["topic"] = topic;
      out_msg["level"] = level;
      out_msg["message"] = message;
      // Prefer source timestamp if present
      if (input.contains("timestamp") && input["timestamp"].is_object() && input["timestamp"].contains("$date")) {
        try {
          if (input["timestamp"]["$date"].is_string()) {
            out_msg["timestamp"] = input["timestamp"]["$date"].get<string>();
          } else {
            out_msg["timestamp"] = now_iso8601();
          }
        } catch (...) {
          out_msg["timestamp"] = now_iso8601();
        }
      } else {
        out_msg["timestamp"] = now_iso8601();
      }
      if (!side.empty()) out_msg["side"] = side;

      // Include details if present (lightweight)
      if (input.contains("code")) out_msg["code"] = input["code"];
      if (input.contains("command")) out_msg["command"] = input["command"];
      if (input.contains("id")) out_msg["id"] = input["id"];
      if (input.contains("timecode")) out_msg["timecode"] = input["timecode"];

      _pending.push_back(out_msg);
      if (_pending.size() > _max_pending) {
        _pending.pop_front();
      }
    }

    return return_type::success;
  }

  // We calculate the average of the last N values for each key and store it
  // into the output json object
  return_type process(json &out) override {
    out.clear();

    if (_pending.empty()) {
      if (_debug) {
        std::cout << "StatusHandler: process retry (no pending messages)" << std::endl;
      }
      return return_type::retry;
    }

    out["status"] = _pending.front();
    _pending.pop_front();

    if (_debug) {
      std::cout << "StatusHandler: emitting status=" << out.dump(4) << std::endl;
    }

    // This sets the agent_id field in the output json object, only when it is
    // not empty
    if (!_agent_id.empty()) out["agent_id"] = _agent_id;
    return return_type::success;
  }
  
  void set_params(const json &params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);

    // provide sensible defaults for the parameters by setting e.g.
    _params["max_pending"] = 100;
    _params["debug"] = false;
    // more here...

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(params);
    _max_pending = _params.value("max_pending", 100);
    _debug = _params.value("debug", false);
      
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };

private:
  // Define the fields that are used to store internal resources
  json _last_input;
  string _last_topic;
  std::deque<json> _pending;
  size_t _max_pending = 100;
  bool _debug = false;

  string now_iso8601() const {
    using namespace std::chrono;
    auto now = system_clock::now();
    auto t = system_clock::to_time_t(now);
    std::tm tm{};
#ifdef _WIN32
    localtime_s(&tm, &t);
#else
    localtime_r(&t, &tm);
#endif
    std::ostringstream ss;
    ss << std::put_time(&tm, "%Y-%m-%dT%H:%M:%S");
    return ss.str();
  }
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Status_handlerPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

int main(int argc, char const *argv[])
{
  Status_handlerPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(params);

  // Set input data
  input["data"] = {
    {"AX", 1},
    {"AY", 2},
    {"AZ", 3}
  };

  // Set input data
  plugin.load_data(input);
  cout << "Input: " << input.dump(2) << endl;

  // Process data
  plugin.process(output);
  cout << "Output: " << output.dump(2) << endl;


  return 0;
}

