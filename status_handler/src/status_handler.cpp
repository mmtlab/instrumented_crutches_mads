/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Status_handlerPlugin, a Filter Plugin
# Generated by the command: C:\Program Files\MADS\usr\local\bin\mads-plugin.exe -t filter -d C:\mirrorworld\instrumented_crutches\status_handler status_handler
# Hostname: unknown
# Current working directory: C:\mirrorworld\instrumented_crutches\status_handler
# Creation date: 2026-01-29T10:48:01.664+0100
# NOTICE: MADS Version 2.0.0
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <deque>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <cctype>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "status_handler"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Status_handlerPlugin : public Filter<json, json> {

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    
    // initialize variables to build the message and determine the level
    string level = "";
    string message = "";
    string side = "";
    bool has_status = false;

    // Get source from agent_id or name field, or use topic as source
    string source = topic.empty() ? "unknown" : topic;
    if (input.contains("name")) {
      try {
        source = input["name"].get<string>();
      } catch (...) {
        // keep topic as source
      }
    } else if (input.contains("agent_id")) {
      try {
        source = input["agent_id"].get<string>();
      } catch (...) {
        // keep topic as source
      }
    }

    // Get side from the side field if present, or from settings if present (from modified_settings first, then from settings)
    // If the side is not specified, it will be set to void and the message will be considered as not related to a specific side
    if (input.contains("side") && input["side"].is_string()) {

      side = input["side"].get<string>();

    } else if (input.contains("modified_settings") && input["modified_settings"].is_object()) {

      try {
        auto settings = input["modified_settings"];
        if (settings.contains("side") && settings["side"].is_string()) {
          side = settings["side"].get<string>();
        }
      } catch (...) {}

    } else if (input.contains("settings") && input["settings"].is_object()) {

      try {
        auto settings = input["settings"];
        if (settings.contains("side") && settings["side"].is_string()) {
          side = settings["side"].get<string>();
        }
      } catch (...) {}

    }

    // Handle the shutdown/startup messages
    if (input.contains("event")){
      if (input["event"].is_string()){
        string event = input["event"].get<string>();
        if (event == "shutdown" || event == "startup") {
          has_status = true;

          // if you have more status handle here the according levels
          level = "info"; // default level is info, but it can be changed based on the event
          if (event == "shutdown"){
            level = "critical";
          } else if (event == "startup") {
            level = "info";
          }
          
          // Build shutdown message
          std::ostringstream oss;
          oss << event;
          
          message = oss.str();
          
          if (_debug) {
            std::cout << "StatusHandler: the agent " << source << " is " << event << "." << std::endl;
          }
        }
      }
    }

    // Handle offset messages from loadcell topic
    if (input.contains("offset") && input.contains("offset_test")) {
      has_status = true;
      level = "warning"; // we want to consider the offset setting as a warning, because it is not an error but it is an important event that we want to be aware of

      // Build offset message
      std::ostringstream oss;
      oss << "offset = " << input["offset"] << " N, test = " << input["offset_test"] << " N";
      
      message = oss.str();
      if (_debug) {
        std::cout << "StatusHandler: offset detected topic='" << topic << "' message='" << message << "'" << std::endl;
      }
    }

    // TODO: implement the same logic in pupil_neon.py agent and then correct this part
    // Handle pupil neon info messages 
    if (input.contains("pupil_neon_connected") || input.contains("pupil_neon_connection_error")) {
      has_status = true;

      // Build neon info message
      std::ostringstream oss;
      oss  << (input.value("pupil_neon_connected", false) ? "connected" : "disconnected");

      if (input.contains("pupil_neon_connection_error") && !input["pupil_neon_connection_error"].is_null()) {
        level = "error";
        oss << " error: " << input["pupil_neon_connection_error"].get<string>();
      } else {
        level = "info";
      }
      
      message = oss.str();
      
      if (_debug) {
        std::cout << "StatusHandler: pupil_neon topic='" << topic << "' message='" << message << "'" << std::endl;
      }
    }

    // Handle health info messages 
    if (input.contains("health_status")) {

      // add side only when needed to distinguish the topic
      string underscore_side = side.empty() ? "" : "_" + side;

      if (input["health_status"].is_string()) {
        message = input["health_status"].get<string>();
        has_status = true;
        level = "info";
      }

      if (_debug) {
        std::cout << "StatusHandler: health status - topic='" << topic << "' message='" << message << "'" << std::endl;
      }
    }

    auto get_string = [&](const char *key) -> string {
      if (!input.contains(key)) return "";
      try { return input[key].get<string>(); } catch (...) { return ""; }
    };

    // If you want to mask certain messages based on the level, remove here the level to not handle
    bool is_relevant =  has_status && (level == "info" || level == "warning" || level == "error" || level == "fatal" || level == "critical");
    
    // proceed only if the message is relevant based on the level, otherwise ignore it
    if (is_relevant) {

      // fallback if the message has not been handled in specific cases above
      if (message.empty()) {
        message = get_string("message");
      }
      if (message.empty()) {
        message = get_string("detail");
      }
      if (message.empty()) {
        message = "Unhandled error event";
      }
      
      if (_debug) {
        std::cout << "StatusHandler: issue detected level='" << level << "' source='" << source << "'";
        if (!side.empty()) std::cout << " side='" << side << "'";
        std::cout << " message='" << message << "'" << std::endl;
      }

      // Build the output json object with the relevant information about the status, and push it to the pending queue
      // note: timestamp and timecode are added by the agent, so no need to add them here (they are the timestamps of the device running this plugin)
      json out_msg;
      out_msg["source"] = source;
      out_msg["topic"] = topic;
      out_msg["level"] = level;
      out_msg["message"] = message;
      if (!side.empty()) out_msg["side"] = side;

      _pending.push_back(out_msg);
      if (_pending.size() > _max_pending) {
        _pending.pop_front();
      }
    }

    return return_type::success;
  }

  // We calculate the average of the last N values for each key and store it
  // into the output json object
  return_type process(json &out) override {
    out.clear();

    if (_pending.empty()) {
      if (_debug) {
        // just print a dot to indicate that the plugin is waiting for messages
        std::cout << ".";
      }
      return return_type::retry;
    }

    out["status"] = _pending.front();
    _pending.pop_front();

    if (_debug) {
      std::cout << std::endl << "StatusHandler: emitting status=" << out.dump(4) << std::endl;
    }

    // This sets the agent_id field in the output json object, only when it is
    // not empty
    if (!_agent_id.empty()) out["agent_id"] = _agent_id;
    return return_type::success;
  }
  
  void set_params(const json &params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(params);

    // Read the parameters for the plugin, set as defaults if not specified
    _max_pending = _params.value("max_pending", 100);
    _debug = _params.value("debug", false);


  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };

private:
  // Define the fields that are used to store internal resources
  std::deque<json> _pending;
  size_t _max_pending = 100;
  bool _debug = false;
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Status_handlerPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

int main(int argc, char const *argv[])
{
  Status_handlerPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(params);

  // Set input data
  input["data"] = {
    {"AX", 1},
    {"AY", 2},
    {"AZ", 3}
  };

  // Set input data
  plugin.load_data(input);
  cout << "Input: " << input.dump(2) << endl;

  // Process data
  plugin.process(output);
  cout << "Output: " << output.dump(2) << endl;


  return 0;
}

