/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Tip_loadcellPlugin, a Filter Plugin
# Generated by the command: C:\Program Files\MADS\usr\local\bin\mads-plugin.exe -t filter -d C:\mirrorworld\instrumented_crutches\tip_loadcell tip_loadcell
# Hostname: unknown
# Current working directory: C:\mirrorworld\instrumented_crutches
# Creation date: 2026-01-11T18:28:16.919+0100
# NOTICE: MADS Version 2.0.0
*/

// To run this plugin remember to use the command with the --dont-block option enabled to avoid blocking while waiting for new data in sub_topic
// mads-filter tip_loadcell.plugin -o side=left --dont-block 

// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <memory> // For std::unique_ptr


#ifdef RASPBERRYPI_PLATFORM
  // Include HX711 for Raspberry Pi
  #include <hx711/common.h>  // Library for HX711
  using namespace HX711;
  #pragma message("This computer has the HX711 library installed.")
#else
  // If we are not on a Raspberry Pi, we don't have the actual sensor, so we can just emulate it by generating random values in the process method, which can be useful for development and testing on non-Raspberry Pi machines
  #pragma message("This computer does not have the HX711 library available, sensor readings will be emulated with random values.")
#endif 

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "tip_loadcell"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Tip_loadcellPlugin : public Filter<json, json> {

public:

#ifdef RASPBERRYPI_PLATFORM
  // Constructor
  Tip_loadcellPlugin() : _hx(nullptr) {}
#endif

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    
    // if topic contains the "command" field, process commands here
    if (input.contains("command")) {

      string action = input.value("command", ""); // Get the command, default to empty string if not found
      if (action == "start") {
        // Check if we are already recording, if yes, return a warning
        if (_recording) {
          _error = "Tip Loadcell: start requested while already recording";
          std::cout << std::endl << "\033[31m" << "Error: " << _error << "\033[0m" << std::endl;
          return return_type::warning;
        }

        _recording = true;
        std::cout << std::endl << "Tip Loadcell: Starting acquisition" << std::endl;

      } else if (action == "stop") {
        // check if we are not recording, if yes, return a warning
        if (_recording == false) {
          _error = "Tip Loadcell: stop requested while not recording";
          std::cout << std::endl << "\033[31m" << "Error: " << _error << "\033[0m" << std::endl;
          return return_type::warning;
        }
        
        _recording = false;
        std::cout << std::endl << "Tip Loadcell: Stopping acquisition" << std::endl;

      } else if (action == "set_offset") {
        
        // Setting offset is only allowed when not recording, if we are recording return an error
        // This is to avoid changing the offset while we are acquiring data, which could lead to inconsistent data and make it difficult to understand the actual forces being applied on the crutches.
        if (_recording) {
          _error = "Tip Loadcell: set_offset not allowed while recording, request ignored";
          std::cout << std::endl << "\033[31m" << "Error: " << _error << "\033[0m" << std::endl;
          return return_type::error;
        }

        _setting_offset = true;
        std::cout << std::endl << "Tip Loadcell: Setting offset" << std::endl;

      } 

      // Just continue if the command is not recognized, we might want to handle it in the process method or just ignore it
    }

    return return_type::success;
  }

  // We calculate the average of the last N values for each key and store it
  // into the output json object
  return_type process(json &out) override {
    out.clear();

    // Not valid states or transitions are handled in load_data, here we just process data
    // Here we should have only valid states and errors related to reading the sensor

    // Send periodic health_status if 500ms have passed
    auto now = std::chrono::steady_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - _last_health_status_time).count();
  
    // load the data as necessary and set the fields of the json out variable
    if (_recording || _setting_offset || elapsed >= _health_status_period) {
      
      if (elapsed >= _health_status_period) {
        out["health_status"] = _recording ? "recording" : "idle";
        _last_health_status_time = now;
      } 

      if (_recording){
        #ifdef RASPBERRYPI_PLATFORM
        
          try {
            if (_hx) {

              // read the load cell value, subtract the offset and store it in the output json object
              float loadCellValue = _hx->weight(1).getValue(Mass::Unit::N);
              out["force"] = loadCellValue - _offset;

            }
          } catch (const std::exception &e) {
            _error = "Tip Loadcell: Error reading from HX711: " + string(e.what());
            return return_type::error;
          }

        #else

          // If we are not on a Raspberry Pi, we emulate the load cell readings by generating random values, which can be useful for development and testing on non-Raspberry Pi machines
          out["force"] = static_cast<float>(rand()) / static_cast<float>(RAND_MAX) * 100.0; // Random value between 0 and 100 N

        #endif
        
      } else if (_setting_offset) {
        #ifdef RASPBERRYPI_PLATFORM
        
          try {
            // Real hardware offset on Raspberry Pi
            float loadCellValue = _hx->weight(40).getValue(Mass::Unit::N);
            _offset = loadCellValue;
            _setting_offset = false;

            // test read after setting offset
            loadCellValue = _hx->weight(20).getValue(Mass::Unit::N);
            auto offset_test = loadCellValue - _offset;
            
            // Store the offset and the test read in the output json for user feedback
            // We only fill the field for the current side
            out["offset"] = _offset;
            out["offset_test"] = offset_test;

          } catch (const std::exception &e) {
            _error = "Tip Loadcell: Error reading from HX711 for offset: " + string(e.what());
            return return_type::warning;
          }

        #else
          // If we are not on a Raspberry Pi, we emulate the offset setting by generating a random offset value, which can be useful for development and testing on non-Raspberry Pi machines
          _offset = static_cast<float>(rand()) / static_cast<float>(RAND_MAX) * 10.0; // Random offset value between 0 and 10 N
          _setting_offset = false;

          float offset_test = static_cast<float>(rand()) / static_cast<float>(RAND_MAX) * 5.0; // Random offset test value between 0 and 5 N

          // Store the offset and offset_test in the output json for user feedback
          out["offset"] = _offset;
          out["offset_test"] = offset_test;

        #endif
      }
    } else {
      // if there is no command to send and not enough time has passed, don't send anything
      return return_type::retry;
    }
    

    // If there is a message to send, we must send the crutch side
    out["side"] = _side;
    
    // This sets the agent_id field in the output json object, only when it is
    // not empty
    if (!_agent_id.empty()) out["agent_id"] = _agent_id;
    return return_type::success;
  }
  
  void set_params(const json &params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);

    // provide sensible defaults for the parameters by setting e.g.
    _params["side"] = "unknown";

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(params);

    _health_status_period = _params.value("health_status_period", 500); // default to 500 ms

    if (_params.contains("side") && (_params["side"] == "left" || _params["side"] == "right")) {
      _side = _params["side"].get<string>();
      std::cout << "Tip Loadcell: Side set to " << _side << std::endl;
    } else {
      _error = "Tip Loadcell: Side parameter not set or invalid (only 'left' or 'right' allowed).";
      std::cout << _error << std::endl;
      throw std::runtime_error(_error);
    }

    // Read configuration parameters for the single HX711 sensor
    int dataPin = _params.value("datapin", 6); // default data pin 6 based on typical Raspberry Pi wiring for HX711
    int clockPin = _params.value("clockpin", 26); // default clock pin 26 based on typical Raspberry Pi wiring for HX711

    double scaling = 1.0; // Default scaling factor
    if (_params.contains("scaling") && _params["scaling"].contains(_side)) {
      scaling = _params["scaling"][_side].get<double>();
    } else {
      _error = "Tip Loadcell: Scaling factor for side '" + _side + "' not found in scaling parameter.";
      std::cout << _error << std::endl;
      throw std::runtime_error(_error);
    }

    #ifdef RASPBERRYPI_PLATFORM

      // Initialize the HX711 sensor
      if (dataPin != -1 && clockPin != -1) {
        _hx = std::make_unique<AdvancedHX711>(dataPin, clockPin, scaling, 0.0, Rate::HZ_80);
        std::cout << "Tip Loadcell: HX711 initialized with dataPin=" << dataPin 
                  << ", clockPin=" << clockPin << ", scaling=" << scaling << std::endl;
      }

    #else

      // If we are not on a Raspberry Pi, we emulate the load cell readings, so no need to initialize the HX711 sensor
      std::cout << "Tip Loadcell: Running in emulation mode, no HX711 initialization needed" << std::endl;

    #endif

    _setting_offset = true; // Set offset at the beginning
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };

private:

  #ifdef RASPBERRYPI_PLATFORM
    // Define the fields that are used to store internal resources
    unique_ptr<AdvancedHX711> _hx;  // Single HX711 sensor
  #else
    // If we are not on a Raspberry Pi, we don't have the actual sensor
  #endif 

  // Control flags
  bool _recording = false;
  bool _setting_offset = false;

  int _health_status_period = 500; // in milliseconds, default to 500 ms
  std::chrono::steady_clock::time_point _last_health_status_time = std::chrono::steady_clock::now();

  // Internal variables
  string _side = "unknown";
  float _offset = 0.0;
  
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Tip_loadcellPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

int main(int argc, char const *argv[])
{
  //
  return 0;
}

