/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for CoordinatorPlugin, a Filter Plugin
# Generated by the command: C:\Program Files\MADS\usr\local\bin\mads-plugin.exe -t filter -d C:\mirrorworld\instrumented_crutches\coordinator coordinator
# Hostname: unknown
# Current working directory: C:\mirrorworld\instrumented_crutches
# Creation date: 2026-01-11T21:54:49.684+0100
# NOTICE: MADS Version 1.4.0
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <chrono>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "coordinator"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class CoordinatorPlugin : public Filter<json, json> {

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    
    // if topic contains "command", process commands here
    if (input.contains("command")) {
    
      string action = input.value("command", ""); // Get the command, default to empty string if not found

      if (action == "start") {
        if (_recording) {
          _error = "recording: start requested while already acquiring";
          return return_type::error;
        }

        // check if id is provided in the input json, if not return an error
        if (!input.contains("id")) {
          _error = "idle: start command requires an id";
          return return_type::error;
        }
        _id_to_send = input.value("id", -1);

        // check if there are optional fields subject_id and session_id in the input json, if yes, store them to send them with the command
        _subject_id_to_send = input.value("subject_id", -1);
        _session_id_to_send = input.value("session_id", -1);

        // add here other optional fields as needed

        // set the flag to send the command in the process method
        _send_command = true;
        _command_to_send = action;

        std::cout << "Sending command " << action << " with id " << _id_to_send << std::endl;
      } else if (action == "stop") {
        if (_recording == false) {
          _error = "idle: stop requested while not acquiring";
          return return_type::error;
        }

        // set the flag to send the command in the process method
        _send_command = true;
        _command_to_send = action;

        std::cout << "Sending command " << action << std::endl;
      } else if (action == "condition") {
        if (input.contains("label")) {
          
          // send with additional field "label" if it is provided in the input json, if not, use "NA" as default value
          _label_to_send = input.value("label", "NA");

          _send_command = true;
          _command_to_send = action;

          std::cout << "Sending command " << action << " with label " << _label_to_send << std::endl;
        }
      } else if (action == "get_agents_status" || action == "set_offset" || action == "pupil_neon_connect" || action == "pupil_neon_disconnect") {
        // add here other commands that doesn't require additional fields or check for them as needed
        _send_command = true;
        _command_to_send = action;
        std::cout << "Sending command " << action << std::endl;
      } else {
        return return_type::retry;
      }
    } else {
      return return_type::retry;
    }

    return return_type::success;
  }

  // We calculate the average of the last N values for each key and store it
  // into the output json object
  return_type process(json &out) override {
    out.clear();

    // Send periodic agent_status if no command to send and 500ms have passed
    auto now = std::chrono::steady_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - _last_health_status_time).count();
    
    // load the data as necessary and set the fields of the json out variable
    if (_send_command || elapsed >= _health_status_period) {

      if (elapsed >= _health_status_period) {
        out["agent_status"] = _recording ? "recording" : "idle";
        _last_health_status_time = now;
      } 

      if (_send_command){
        out["command"] = _command_to_send;

        if (_command_to_send == "start") {

          out["id"] = _id_to_send; // include id only for start command
          if (_subject_id_to_send != -1) {
            out["subject_id"] = _subject_id_to_send;
          }
          if (_session_id_to_send != -1) {
            out["session_id"] = _session_id_to_send;
          }
          _recording = true;
          
          // update health status immediately when starting acquisition, so that the agent can react to it without waiting for the next periodic update
          out["agent_status"] = "recording";

        } else if (_command_to_send == "stop") {

          _recording = false;
          out["agent_status"] = "idle";

        } else if (_command_to_send == "condition") {

          out["label"] = _label_to_send;
        
        }
        // do nothing special for other commands for now, just send the command
      }

      // always reset the command to send after sending it, so that we don't send it again in the next iteration
      _send_command = false; // reset the flag
      _command_to_send = ""; // reset the command

    } else {
      // if there is no command to send and not enough time has passed, don't send anything
      return return_type::retry;
    }

    // This sets the agent_id field in the output json object, only when it is
    // not empty
    if (!_agent_id.empty()) out["agent_id"] = _agent_id;
    return return_type::success;
  }
  
  void set_params(const json &params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(params);

    _health_status_period = _params.value("health_status_period", 500); // default to 500 ms
      
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };

private:
  // Define the fields that are used to store internal resources
  bool _recording = false;
  bool _send_command = false;

  string _command_to_send = "";

  int _health_status_period = 500; // in milliseconds, default to 500 ms
  std::chrono::steady_clock::time_point _last_health_status_time = std::chrono::steady_clock::now();

  int _id_to_send = -1;
  int _subject_id_to_send = -1;
  int _session_id_to_send = -1;
  string _label_to_send = "NA";
  
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(CoordinatorPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

int main(int argc, char const *argv[])
{
  CoordinatorPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(params);

  // Set input data
  input["data"] = {
    {"AX", 1},
    {"AY", 2},
    {"AZ", 3}
  };

  // Set input data
  plugin.load_data(input);
  cout << "Input: " << input.dump(2) << endl;

  // Process data
  plugin.process(output);
  cout << "Output: " << output.dump(2) << endl;


  return 0;
}

